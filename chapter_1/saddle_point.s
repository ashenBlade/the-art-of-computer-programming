.globl main

# !!! КОД не работает правильно

# Входные данные

# Матрица, в которой ищем седловую точку (6 строка, 4 столбец)
.section .data
matrix: .quad    10,  20,  30,  11,  50,  60,  70,  80
        .quad    20,  30,  40,  12,  60,  70,  80,  90
        .quad    30,  40,  50,  13,  70,  80,  90, 100
        .quad    40,  50,  60,  14,  80,  90, 100, 110
        .quad    50,  60,  70,  15,  90, 100, 110, 120
        .quad    60,  70,  80,  40, 100, 110, 120, 130
        .quad    70,  80,  90,  16, 110, 120, 130, 140
        .quad    80,  90, 100,  17, 120, 130, 140, 150
        .quad    90, 100, 110,  18, 130, 140, 150, 160

# Заполняется в процессе работы
# Индексы минимального элемента для каждой строки (номер столбца этой строки)
rows_min: .quad 0, 0, 0, 0, 0, 0, 0, 0, 0
# Индексы максимального элемента для каждого столбца (номер строки этого столбца)
cols_max: .quad 0, 0, 0, 0, 0, 0, 0, 0

.section .text
main:
    # Для нахождения седловой точки найдем мин/макс элементы строк/столбцов
    # После находим пересечения: индекс из rows_min должен быть равен какому-нибудь индексу из cols_max
    # 
    # Используемые регистры:
    #  %r8  - текущий индекс строки (внешний цикл)
    #  %r9  - текущий индекс столбца (внутренний цикл)
    #  %r10 - минимальное значение для этой строки
    #  %r11 - максимальное значение для этого столбца
    #  %r12 - значение текущего элемента
    #  %r13 - адрес текущего числа
    #  %r14 - адрес начала cols_max
    #  %r15 - адрес начала rows_min

    pushq %rbp
    movq %rsp, %rbp
    pushq %r12
    pushq %r13
    pushq %r14
    pushq %r15

    # Итерация начинается с 0
    movq $0, %r8
    movq $0, %r9
    # Минимальное и максимальное значения - это первый элемент матрицы, A_00
    leaq matrix(%rip), %r13
    movq (%r10), %r10
    movq %r10, %r11

    leaq cols_max(%rip), %r14
    leaq rows_min(%rip), %r15

loop_seed_start:
    # Обновляем макс. столбец
    movq (%r14, %r9, 8), %rax  # индекс макс в столбце
    leaq (,%rax, 8), %rax
    leaq (%r13, %rax, 8), %r11
    # TODO: хуйня - переделывать
    movq (%r11, %r9, 8), %r11

    # Обновляем мин. строку
    movq (%r15, %r8, 8), %rax  # индекс мин в строке
    leaq (,%r8, 8), %r10
    leaq (%r13, %r10, 8), %r10
    movq (%r10, %rax, 8), %r10

    # Читаем очередное число
    movq (%r13), %r12

loop_seed_cmp_row:
    # Сравниваем его с наименьшим в строке
    cmpq %r12, %r10
    jle loop_seed_cmp_col
    
    # Обновляем информацию о строке: минимальный индекс и элемент
    movq %r9, (%r15, %r8, 8)

loop_seed_cmp_col:
    # Сравниваем с наибольшим в столбце
    cmpq %r12, %r11
    jge loop_seed_next

    movq %r8, (%r14, %r9, 8)

loop_seed_next:
    # Переходим к следующему числу
    addq $8, %r13
    # Переходим к следующему столбцу
    incq %r9
    cmpq $8, %r9
    jne loop_seed_start

loop_seed_next_row:
    # Если закончились столбцы - переходим к следующей строке
    # Не забываем обновить минимальное значение в этой строке
    incq %r8
    movq $0, %r9

    cmpq $9, %r8
    jne loop_seed_start

loop_seed_end:
    # В конце необходимо найти такую ситуацию: 
    #     cols[rows[cols_max]] == cols_max
    # То есть, индекс из rows указывает на индекс в rows (друг на друга указывают)
    # Здесь необходимо пройтись по всему массиву rows и делать проверки
    #
    # Используемые регистры:
    #  - %r8  - индекс в rows (переменная итерирования) - rows_min
    #  - %r9  - прочитанный индекс cols_max
    #  - %r10 - прочитанный индекс rows_min
    #  - %r14 - адрес rows_max
    #  - %r15 - адрес cols_min

    movq $0, %r8

loop_find_start:

    # Проверка - прочитанный обратно rows_min должен быть равен переменной итерирования (%r8)
    movq (%r15, %r8, 8), %r9 
    movq (%r14, %r9, 8), %r10
    cmpq %r8, %r10
    je find_saddle_point
    
loop_find_next:
    incq %r8
    cmpq $9, %r8
    jne loop_find_start
    movq $-1, %rax
    jmp program_end

find_saddle_point:
    # Мы нашли седловую точку - %r9 - строка, %r10 - столбец.
    # Выведем это значение
    leaq (%r9, %r8, 8), %rax

program_end:
    popq %r15
    popq %r14
    popq %r13
    popq %r12
    movq %rbp, %rsp
    popq %rbp
    ret

# Глава 1

## 1.1

Упражнения:

### 1

```text
(a, b, c, d) = (b, c, d, a)
```

Это похоже на циклический сдвиг. Для решения используем временную переменную
`t` - в нее сохраним `a` и будем сдвигать значения переменных влево.

```text
t <- a   |    abcda
a <- b   |    bbcda
b <- c   |    bccda
c <- d   |    bcdda
d <- t   |    bcdaa
```

### 2

Здесь надо воспользоваться формулой `m = q * n + r`, где `0 <= r < n` - остаток
от деления.

На последнем шаге мы присваиваем `m <- n` и `n <- r`:

- `m > n` - так как на 1-ом шаге это условие выполняется по умолчанию (в начале E0 это всегда так)
- `n > r` - так как `0 <= r < n` по определению остатка (условие выше)

### 4

[gcd.cpp](./chapter_1/gcd.cpp) - `57`

### 6

| `n` | `m` | count |
| --- | --- | ----- |
| 5   | 1   | 1     |
| 5   | 2   | 2     |
| 5   | 3   | 3     |
| 5   | 4   | 2     |
| 5   | 5   | 1     |

Среднее - 1.8

### 7

Пусть у нас имеется `m - Const` и `0 < n <= m`.

Предположим, что Um - недетерминировано. Это значит, что для одного и того же `n`
будет разное представление его разложения (так как все зависит от остатка).

Представим, что у нас имеется ряд значений `n` - от 1 до m. Тогда существует
такое `i`, что `q_i_1 * n + r_i_1 = m = q_i_2 * n + r_i_2`, то есть у `m` имеется
одинаковое разложение для одного и того же `n`.

Так как `q_i` должны быть разные и целые, то представим, что `q_i_1 = q_i_2 + x`,
то есть `q` слева больше `q` справа. Тогда имеем следующее разложение:

```text
q_i_2 * n + x * n + r_i_1 = q_i_2 * n + r_i_2
x * n + r_i_1 = r_i_2
```

Значит, `r_i_2` больше `r_i_1`, но по условию остатка `0 <= r < n` и так как
`x > 0` (по предположению), то `n < r_i_2`, что противоречит определению остатка.
Соответственно, у одного и того же числа должно быть одно и то же значение
остатка -> Um определено для каждого `n`, а значит и для каждого `m`.

## 1.2.1

### 1

Для доказательства методом мат. индукции для всех неотрицательных чисел (0, 1, 2)
необходимо начинать доказательство с 0, а не 1.

### 2

Ошибка в доказательстве - неправильное разложение `a^n` на дробь: числитель в
равен

```text
(a^(n - 1) * a^(n - 1)) / a^((n - 1) - 1)
```

и потом упрощается до

```text
(1 * 1) / 1
```

но правильное упрощение:

```text
a^(2n - 2) / a^(n - 2)
```

Из этого места уже нельзя упростить до `1 / 1`.

### 3

Скорее всего ошибка в выборе n - начинать надо с n = 2, т.к. при n = 1 получим
деление на 0:

```text
1 / ((n - 1) * n) = 1 / (0 * 1) = 1 / 0
```

а с правой стороны у нас будет:

```text
3 / 2 - 1 / n = 3 / 2 - 1 / 2 = 1
```

Теперь у нас и появляется расхождение, так как подстановка параметра в формуле
произошло неправильно.

А для, например, 3 будет:

```text
1 / (1 * 2) + 1 / (2 * 3) = 3 / 2 - 1 / 3
2 / 3 = 4 / 3
```

Уже идет неправильно

### 4

Здесь также воспользуемся равенством золотого сечения $1 + \phi = \phi^2$.
Теперь будем раскрывать

```math
F_{n + 1} = F_{n - 1} + F_n 
\le
\phi^{n - 3} + \phi^{n - 2} = \phi^{n - 2}(1 + \phi) = \phi^{n - 1}
```

В результате мы получили $F_{n + 1} = \phi^{n - 1}$ - это тоже самое, что и при подстановке n + 1

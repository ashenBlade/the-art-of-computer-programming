# Глава 2

## 2.2.1

### 2

**Решено**

1.  push 1
2.  push 2
3.  push 3
4.  pop     # 3
5.  pop     # 2
6.  push 4
7.  push 5
8.  pop     # 5
9.  push 6
10. pop     # 6
11. pop     # 4
12. pop     # 1

Вторую перестановку можно сделать, если в изначальной последовательности поменять местами 2 и 3.

### 5

**Решено**

Здесь причина в инварианте стека: когда кладу (из последовательности 1 2 3 ... N - возрастающей) на вершину стека очередной элемент, то все элементы под ним будут строго меньше, соответственно, когда убираем, то в итоговой последовательности будут идти в таком же порядке. Но если посмотреть, на $p_j < p_k < p_i$, то можно заметить, что это возможно только если $p_i$ добавлен последним, то есть j и k были в стеке. Но при этом почему-то $p_j < p_k$ - это противоречие инварианту стека, т.к. k добавлен раньше j, а значит должен $p_j$ быть меньше.

## 2.2.2

### 1

**Решено**

При удалении OVERFLOW быть не может, а при вставке - сколько угодно, но главное, чтобы все было незанято

6 a - $M$

7 a - $M - 1$

### 2

**Решено**

Вывод с конца

```text
F == R ? -> Underflow
Y = X[R]
R == 1 ? R = M : R = R - 1
```

Ввод с начала

```text
F == 1 ? F = M : F = F - 1
F = R ? -> Overflow
X[F] = Y
```

## 2.2.3

### 1

**Не решено** - не знаю откуда здесь неявная обработка

Предполагается что памяти хватит (т.к. не ограничивали), либо будет работать сборщик мусора

### 7

**Решено** - практически то же самое

Если в списке 0 или 1 элемент, то ничего делать не нужно

1. Начинаем с 1 элемента
2. Переходим к следующему элементу
3. Запоминаем текущий указатель
4. Выставляем текущий указатель на предыдущий узел
5. Если указатель `NULL` - Переходим на шаг 7
6. Переходим к элементу по сохраненному указателю
7. Выставляем указатель 1-ого элемента в `NULL` (теперь последний)
8. Выставляем текущий указатель головы списка в последний просмотренный элемент

### 11

**Не решено** - количества я не дал

Лень находить все. Обнаружил:

1. 9 можно вставлять куда угодно до текущей позиции, т.к. нет родителей
2. 2 тоже куда угодно, то после 9 и до 8
3. 5 можно не ранее 9 и 7

## 2.2.4

### 3

**Решено**

PTR2 станет равным NULL

### 5

**Решено**

1. Начинаем с элемента, куда указывает PTR
2. Переходим к следующему элементу
3. Если этот элемент указывает на PTR - конец
4. Запоминаем указатель на следующий элемент
5. Выставляем указатель на следующий элемент равным предыдущему
6. Переходим к шагу 2 (указатель, который запомнили)

### 8

**Решено**

Если после сложения коэффициент будет равен 0, то мы сможем удалить этот элемент, т.к. знаем родителя и сможем обновить указатель

### 9

**Не решено** - с 0 даст некорректный результат, другие случаи X = Y тоже будут корректны

Если указатели на одинаковые списки, то работа алгоритма останется корректной. Так как мы всегда будем идти по ветке ABC(P) = ABC(Q). Если нам попадется коэффициент 0, то все равно будет верно работать.

Правильно будет работать, только если P = M, т.к. эти 2 списка не изменяются по ходу работы алгоритма.

### 10

**Решено**

Особо много никаких, разве что представление в MIX - `ABC` теперь не 3 отдельных поля по 1 байту, а единое целое число.

### 17

**Не решено** - много нет преимуществ

Всегда можно выполнить сложение с любого места, т.к. от изменения мест слагаемых сумма не меняется.

### 18

**Не решено** - используется трюк с XOR и перемещением 2 указателей

Используем дополнительно стек, реализованный на списке. Когда проходим к очередному узлу, то добавляем этот узел в стек.

Таким образом, везде только 1 указатель хранится и проход возможен в 2 направления.

## 2.2.5

### 2

**Не решено** - проблема в удалении нескольких записей одновременно

Удаление/вставка в списке только с 1 конца быстро можно выполнить. Дек может с 2 сторон. (Если для списка храним указатель только на начало)

### 11

**Не решено** - в `LINK` храним индексы, которые образуют связный список

Эти 2 таблицы используем как список. Индекс будет указывать номер записи.

- `NEWV` - новое записанное значение
- `LINK` - индекс переменной, по которой записываем значение

Таким образом, итерируемся по `LINK` пока не найдем конец. Каждое значение `j = LINK[i]` - это индекс в массиве `V`. Далее, `V[j] = NEWV[i]`.

Также при каждой новой записи проходимся по предыдущим элементам и находим `LINK[i]` с таким же индексом. Если нашли, то ошибка.

## 2.2.6

### 2

**Решено**

Если это ограничение логическое, то ничего не меняется. Но если это влияет на механизм хранения, то $a_r = c\prod_{r < s \le k}(u_r - l_r + 1)$. Если подставить d и 0, то получим исходную формулу.

### 13

**Не решено**

Чтобы находить границы матрицы

## 2.3

### 6

**Не решено** - я не дал мат. определения

`X - m-родный кузен` - значит в генеалогическом дереве, между `X` и общим предком - `m` узлов.

### 8

**Не решено** - бинарное дерево - это не дерево ЧЗХ?

Связный список - есть только 1 потомок у каждого узла

### 15

**Решено**

У каждого узла будет свой номер: 0 - левый узел, 1 - правый. Соответственно, путь до узла - это последовательность 0 и 1, на какой сворачивать. Корень - это ничего.

0010 - лево, лево, право, лево

### 20

**Не решено**

0-2 дерево состоит либо из 1 узла (нечет), либо у него есть еще 2 потомка. Таким образом, у 0-2 узла - `2n + 1` узлов, нечет.

Соответствие можно установить по формуле - для 1 узла ставим дерево из 1 узла, а дальше каждому `n` ставим в соответствие `2n + 1`: 1 - 1, 2 - 3, 3 - 5, 4 - 7 ...


